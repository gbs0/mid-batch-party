
# VocÃªs estÃ£o prontos Wagoners?

<img align="right" srcset="https://i.imgsafe.org/2c/2c024270b3.gif, https://i.imgsafe.org/2c/2c024270b3.gif 1.5x, https://i.imgsafe.org/2c/2c024270b3.gif 2x" src="https://i.imgsafe.org/2c/2c024270b3.gif" width="150px;" />

NÃ³s queremos te desafiar! E por isso preparemos neste repositÃ³rio, alguns desafios em `Ruby` ğŸ‘©â€ğŸ’»

Esse repositÃ³rio foi criado com a proposta de codar e beber! Assim como no filme **[A Rede Social!](https://awesome.re)**

Agradecimentos especiais para [Ana]() e [Roberto]() que se propuseram em ajudar com Ã³timas ideias e modificaÃ§Ãµes â¤ï¸



## Bem Vindos a Mid-Batch Party! ğŸ”¥

Uma festa Ã¡tipica, com pessoas bacanas, drinks, rakes errados e claro, com a trilha sonora dos Jogos Vorazes pra harmonizar toda competiÃ§Ã£o etilÃ­ca!

JÃ¡ na prÃ³xima semana, **Rails** entrarÃ¡ de vez em nossas vidas, e com isso o Ruby se tornarÃ¡ de novo presente em nosso dia a dia, e vocÃªs precisarÃ£o lembrar de alguns conceitos vistos nas primeiras semanas 

## Regras ğŸ“Œ


#### â€¢ 1Âº DivisÃ£o dos Times ğŸ‘¥
- Os times serÃ£o divididos de acordo com os grupos criados pelo **Kitt**;
- Cada programador ou programadora se reveza durante os desafios;

#### â€¢ 2Âº Desafios e Testes ğŸ’¾
- Os testes serÃ£o executados ao rodarem o **Rake**;

- A equipe que cumprir todos o prÃ©-requisitos de cada rodada de testes no Rake e finalizar primeiro ganharÃ¡ **1 ponto**

- Cada programador ou programadora se reveza durante os desafios;

- Cada jogador que codou na rodada deverÃ¡ sofrer as consequÃªncias das regras do jogo, tanto p/ perder ou ganhar, ou talvez nÃ£o ganhar nem perder, apenas se divertir.

#### â€¢ 3Âº Marcando o ponto ğŸ‰

- A equipe que terminar o teste com Ãªxito deve correr atÃ© a almofada com o desenho de uma gema mais prÃ³xima!


## Que os Desafios Comecem ğŸ¤– !!


### 1Âº - Par ou Impar? ğŸ™Œ

Escreva uma funÃ§Ã£o em Ruby que receba um `Integer` como **parÃ¢metro** e retorne `"Even"` para nÃºmeros **pares** e `"Odd"` p/ nÃºmeros **Ã­mpares**

**Exemplo:**

>  `2` => Even
>  `3` => Odd

----

### 2Âº - SomatÃ³ria de Positivos ğŸ™Œ

O metodo receberÃ¡ um `Array` de nÃºmeros.

Ã‰ o seu papel fazer com que este mÃ©todo retorne a soma, **exclusivamente**, dos nÃºmeros **positivos!**


**Exemplo:**

>  `[1,-4,7,12]` => 1 + 7 + 12 = 20

> Nota: se nÃ£o houver nada p/ somar, o resultado **default** terÃ¡ de ser 0.

----


### 3Âº - Contador de Vogais ğŸ™Œ

Retorne o nÃºmero (contagem) final de vogais em uma string.

Considere `'a', 'e', 'i', 'o', 'u'` como as vogais desta challenge

> Nota: As strings do teste vÃ£o serÃ£o somente constituidas por letras!


**Exemplo:**

>  `abracadabra` => 5 `myth` => 0

----


### 4Âº - NÃºmeros Opostos â†”ï¸

Dado um nÃºmero, retorne qual Ã© seu oposto. Caso nÃ£o seja um nÃºmero, o resultado deverÃ¡ ser 0.

**Exemplo:**

> ``1 => -1
14 => -14
-34 => 34``

> Nota: Verifique primeiro se o parametro que o mÃ©todo recebe Ã© um **NÃšMERO**

---


### 5Âº - Soma dos Restantes â•

Retorne a soma de todos os nÃºmeros da array exceto os seu valor mÃ¡ximo e valor minÃ­mo

**Exemplo:**

> ``
[ 6, 2, 1, 8, 10 ] => 16
[ 1, 1, 11, 2, 3 ] =>  6 
``

> Nota: Caso algum nÃºmero das extremidas se repita (valor minimo ou mÃ¡ximo), sua duplicata deve ser mantida.

---


### 6Âº - Acumulador 

Dessa vez, sem papo furado ou teoria, simplesmente olhe o exemplo abaixo e implemente a funÃ§Ã£o `accum(string)`

**Exemplo:**

> ``accum("abcd") -> "A-Bb-Ccc-Dddd"
accum("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
accum("cwAt") -> "C-Ww-Aaa-Tttt"
``

> Nota: O parametro string do mÃ©todo accum inclui apenas letras de a..z ou A..Z

---

